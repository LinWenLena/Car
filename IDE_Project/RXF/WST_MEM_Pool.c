/**
* \ingroup memman
* \class WST_MEM_Pool
* \brief Memory Management Class: Memory Pool
*
* Organizes the memory pool
*
* Willert Software Tools - RealTime eXecution Framework
*
* Email: support@willert.de
*
* $Id: WST_MEM_Pool.c 30180 2014-09-29 12:38:48Z eroemer $
* $URL: https://svn.willert.de/V6/trunk/Component/Shared/Source/C/WST_MEM_Pool.c $
*
**/


/*****************************************************************************
 *
 * This file belongs to the Willert Software Tools RXF Product:  
 * EA_C_OORTX_Keil_ARM_MCB1700_Dev (2014-11-14).
 * Copyright (c) 2013, Willert Software Tools GmbH.
 *
 * For detailed information about this product see release info file:
 * C:/Willert/EA_C_OORTX_Keil_ARM_MCB1700_Dev/ReleaseInfo.txt
 *
 *****************************************************************************/


#include "WST.h"


#define WST_RXF_RUNNING_START_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */

static WSTBoolean isEmpty(const WST_MEM_Pool* const me);

#define WST_RXF_RUNNING_STOP_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */


/**
* \brief Initializes the memory pool object.
* \param me Pointer to WST_MEM_Pool object
* \param initialNumber Initial number of memory blocks.
* \param structSize Size of a memory block plus 'next' pointer.
* \param memory Pointer to the memory area.
*/

#define WST_RXF_RUNNING_START_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */

void WST_MEM_Pool_init( WST_MEM_Pool* const me, uint16 initialNumber, uint16 structSize, void *memory )
{
	struct WSTMemoryBlock*   currentBlock;
	struct WSTMemoryBlock*   previousBlock;
	uint16					 b;

#ifdef	WST_RXF_RXF

	WST_MTX_init( &me->memoryMutex );	/* This function will complain itself on failure */

#endif	/* WST_RXF_RXF */

	me->blockSize = structSize - (uint16) sizeof( struct WSTMemoryBlock *);
	me->freeList = NULL;
	me->use = (uint16) 0;
	me->maxBlocks = initialNumber;						/* This function is called at init time, not interrupted so this will be our end number */
	currentBlock = (struct WSTMemoryBlock*) memory;
	previousBlock = NULL;

	/* Divide up allocated memory into blocks and add to the free list */
	for ( b = (uint16) 0; b < initialNumber; b++ )
	{
		me->freeList = currentBlock;

		/* Get top of current block to point to previous block */
		currentBlock->next = previousBlock;

		/* point to next block */
		previousBlock = currentBlock;

/*lint -save -e511 -e571  */
/* @MISRA_11.4,17.4=OFF ID-0009: There are three memory pools declared in WST_MemoryAllocationPackage that only differ in the last member's size. The general WSTMemoryBlock pointer can be used to access the current block pointer no matter which size the memory block actally has, as it is always the first element. Also a warning generated by QAC, Pointer cast to stWSTter alignment, will not cause any problems as the pointers will still be aligned to the structs. Pointer Arithmetics are necessary to create the flexible linked list of memory blocks. */

		currentBlock = (struct WSTMemoryBlock*) ( ((struct_t *) currentBlock) + (structSize / sizeof(struct_t)) );

/* @MISRA_11.4,17.4=ON ID-0009 */
/*lint -restore	*/

	}
}

#define WST_RXF_RUNNING_STOP_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */



/**
* \brief Cleans up memory pool class.
* \param me Pointer to WST_MEM_Pool object
*/

#define WST_RXF_RUNNING_START_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */

void WST_MEM_Pool_Cleanup(WST_MEM_Pool* const me)
{
	me->freeList = NULL;
}

#define WST_RXF_RUNNING_STOP_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */




/**
* \brief Reserves a pointer for a free memory block from this pool.
* \param me Pointer to WST_MEM_Pool object
* \return Pointer to memory block.
*
* It is taken from the beginning of the free list for fast and deterministic memory block management.
*/

#define WST_RXF_RUNNING_START_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */

void* WST_MEM_Pool_getMemory( WST_MEM_Pool* const me )
{
	void	*p;
	
	/* Check the me pointer */
	if ( NULL == me )
	{
		WST_ERR_error( WST_ERR_EMPTY_ME_PTR );
		p = NULL;
	}
	else if ( me->blockSize == 0U )
	{

#if defined( _DEBUG ) || defined( WST_FORCE_ALLOC_FAILED )

		WST_ERR_error( WST_ERR_ALLOC_FAILED );

#endif	/* _DEBUG or WST_FORCE_ALLOC_FAILED */

		p = NULL;
	}
	else
	{ 
#ifdef	WST_RXF_RXF

		WST_MTX_enterCriticalRegion( &me->memoryMutex );	/* This function will complain itself on failure */

#endif	/* WST_RXF_RXF */

		if ( isEmpty(me) == WSTTRUE )
		{
			p = NULL;
		}
		else
		{
			struct WSTMemoryBlock* block;
	
			/* Take a block off the freelist */
			block = me->freeList;
			me->freeList = block->next;

#ifdef	WST_RXF_RXF
	
			WST_MTX_exitCriticalRegion( &me->memoryMutex );	/* This function will complain itself on failure */

#endif	/* WST_RXF_RXF */
	
			me->use++;
	
			p = (void *) block->memory;
		}
	}
	return p;

/*lint -save -e429	Custodial pointer 'block' has not been freed or returned */

}
/*lint -restore */

#define WST_RXF_RUNNING_STOP_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */




/**
* \brief Returns, if the memory pool is empty (no free memory blocks available).
* \param me Pointer to WST_MEM_Pool object
* \return TRUE if the memory pool is empty, FALSE otherwise.
*/

#define WST_RXF_RUNNING_START_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */

static WSTBoolean isEmpty(const WST_MEM_Pool* const me)
{
	WSTBoolean ret;
	if ( NULL == me->freeList )
	{
		ret = WSTTRUE;
	}
	else
	{
		ret = WSTFALSE;
	}
	return ret;
}

#define WST_RXF_RUNNING_STOP_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */




/**
* \brief Returns memory to the memory pool to be freely used again.
* \param me Pointer to WST_MEM_Pool object
* \param memory Pointer to the memory block.
*
* It is returned to the beginning of the free list for fast and deterministic memory block management.
*/

#define WST_RXF_RUNNING_START_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */

void WST_MEM_Pool_returnMemory( WST_MEM_Pool* const me, FREE_ARGUMENT_TYPE  memory )
{
	struct WSTMemoryBlock* block;

	/* Check the me pointer */
	if ( NULL == me )
	{
		WST_ERR_error( WST_ERR_EMPTY_ME_PTR );
	}
	/* Check the me pointer */
	else if ( NULL == memory )
	{
		WST_ERR_error( WST_ERR_EMPTY_MEMORY_PTR );
	}
	else
	{
		block = (struct WSTMemoryBlock *) ( ((struct_t *) memory) - ( sizeof(struct WSTMemoryBlock *) / sizeof(struct_t) ) );

#ifdef	WST_RXF_RXF

		WST_MTX_enterCriticalRegion( &me->memoryMutex );	/* This function will complain itself on failure */

#endif	/* WST_RXF_RXF */

		/* Put back a block to the freelist */
		block->next = me->freeList;
		me->freeList = block;

#ifdef	WST_RXF_RXF

		WST_MTX_exitCriticalRegion( &me->memoryMutex );	/* This function will complain itself on failure */

#endif	/* WST_RXF_RXF */
		me->use--;

	} /* else for error checking */
}

#define WST_RXF_RUNNING_STOP_SEC_CODE_FAST
/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */
