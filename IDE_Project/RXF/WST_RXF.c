/**
* \ingroup runtime
* \brief This package contains the main interface functions into the RXF.
*
* Initialization, starting and executing the RXF scheduler is handled by this class.
* Also the scheduler is able to cancel all events and timeouts for a specific
* destination onject.
*
* Willert Software Tools - Realtime eXecution Framework
*
* Email: support@willert.de
*
* $Id: WST_RXF.c 30489 2014-10-24 13:53:50Z mspieker $
* $URL: https://svn.willert.de/V6/trunk/Component/RXF/OORTX/Source/C/WST_RXF.c $
*
**/

/*****************************************************************************
 *
 * This file belongs to the Willert Software Tools RXF Product:  
 * EA_C_OORTX_Keil_ARM_MCB1700_Dev (2014-11-14).
 * Copyright (c) 2013, Willert Software Tools GmbH.
 *
 * For detailed information about this product see release info file:
 * C:/Willert/EA_C_OORTX_Keil_ARM_MCB1700_Dev/ReleaseInfo.txt
 *
 *****************************************************************************/


#include "WST.h"


/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#define WST_RXF_RUNNING_START_SEC_CODE_FAST
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */


/**
* \brief Initializes the framework.
* \see WSTInit_prepareTimer
* \see WSTTarget_TimerTick
* \see WSTInit_prepareMemoryAllocation
*
* This function is called in a xxxMain() function generated by the modelling tool in the 
* main component source, when the user specifies to generate an executable. 
*/

sint16 WST_RXF_init( void )
{
	WST_TMM_init();
	WST_MSQ_init();
	WST_MEM_init();

	return (sint16)TRUE;

/*lint -save -e715 Symbols 'numProgArgs', 'defaultPort', 'defaultHost', 'isRealTimeModel', 'progArgs', 'maxTm' and 'tickTime' not referenced */
}

/*lint -restore */

/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#define WST_RXF_RUNNING_STOP_SEC_CODE_FAST
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */


/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#define WST_RXF_RUNNING_START_SEC_CODE_FAST
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */

void WST_RXF_start( void )
{
	WST_RXF_execute();
}



/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#define WST_RXF_RUNNING_STOP_SEC_CODE_FAST
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */


/**
* \brief Cancels all events in the event queue and timeouts for the specified destination.
* \param destination Destination that defines, which events will be canceled.
*/


/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#define WST_RXF_RUNNING_START_SEC_CODE_FAST
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */

void WST_RXF_cancelEventsAndTimeouts(const WST_FSM*  destination)
{
	WST_TMM_cancelEvents ( destination );
	WST_MSQ_cancelEvents ( destination, (WST_EVT_ID_t)0 );
}


/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#define WST_RXF_RUNNING_STOP_SEC_CODE_FAST
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */





/**
* \relates WST_RXF
* \brief This is the never ending main loop.
* \return This operation never returns.
*
* It passes the next event from the event queue on to its destination or
* loops until there is at least one event in the queue again to process.
*/


/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#define WST_RXF_RUNNING_START_SEC_CODE_FAST
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */

void WST_RXF_execute( void )
{
#ifdef WST_MODELLING_RPY
	/* result only used for Rhapsody compatibility, where a destroy via vtable may be called */
	WST_EVT_handleEventStatus  result = WST_EVT_handleEventError;
#endif /* of WST_MODELLING_RPY */

	WST_EVT*    event;

	while ( WSTTRUE )
	{
		/* while the event queue is empty */
		while ( mainMSQ.eventHead == NULL )
		{



#if WST_TMM_MAX_IRQ_TIMEOUTS > 0
				WST_TMM_handleIRQTimeouts();
#endif /* WST_TMM_MAX_TMP_TIMEOUTS > 0 */

			if (WST_TMM_processedTicks != WSTRTOS_getRxfTicks())
			{
				WST_TMM_processTimeouts();
			}
			else
			{
				WSTTarget_sleep(1ul);
			}
		}
		
#if WST_TMM_MAX_IRQ_TIMEOUTS > 0
		WST_TMM_handleIRQTimeouts();
#endif /* WST_TMM_MAX_TMP_TIMEOUTS > 0 */

		/* Process the timers when an event is found as well,
		 * it is possible that the event load is so high
		 * that we never can process the timers.
		 */

		if ( WST_TMM_processedTicks != WSTRTOS_getRxfTicks() )
		{
			WST_TMM_processTimeouts();
		}

		/* we have an event, so extract it from the event queue */
		event = WST_MSQ_get();

		if ( event != NULL )
		{
			if( (event->id != WST_TMR_delete_id) &&
				(event->id != WST_EVT_delete_id) )
			{
				if( event->destination == NULL )
				{
					WST_ERR_error( WST_ERR_NULL_DESTINATION );
				}
				else
				{
	
#ifdef WST_MODELLING_RPY
	/* result only used for Rhapsody compatibility, where a destroy via vtable may be called */
					result = 
#endif /* of WST_MODELLING_RPY */
					/* find out who needs to receive it and send it them */
					WST_FSM_takeEvent( event->destination, event );
				}
			}

			/* Now that the event has been processed, we must delete it. */
			if ( ( event->id == WST_TMR_id ) ||
				 ( event->id == WST_TMR_delete_id ))
			{
/*lint -save -e740 -e826 Unusual pointer cast (incompatible indirect types) */
	
				WST_TMM_putBack( (WST_TMR*) (event) );
	
/*lint -restore */
			}
			else
			{
				if ( event->isStatic == WSTFALSE )
				{
					WST_EVT_destroy( event );
				}
			}
	
#ifdef WST_MODELLING_RPY /* vtable only used for Rhapsody compatibility */
			/*
			 * Check if the statechart is finished. The Object must be destroyed then
			 */
			if (result == WST_EVT_handleEventReachTerminate)
			{
				if ( ( (event->destination != NULL)
					&& (event->destination->vtbl != NULL) )
					&& (event->destination->vtbl->destroyMethod != NULL) )
				{
					event->destination->vtbl->destroyMethod(event->destination->owner);
				}
				else
				{
					/* We dont do that in the OO RTX             WST_FSM_destroy(event->destination); */
				}
			}
#endif /* WST_MODELLING_RPY */
		}
	} /* end of while(WSTTRUE) */
}



/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#define WST_RXF_RUNNING_STOP_SEC_CODE_FAST
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */



/**
* \brief Like the execute() main loop, but this operation has no loop and returns.
*
* It passes one event from the event queue on to its destination or
* does nothing and returns.
*/


/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#define WST_RXF_RUNNING_START_SEC_CODE_FAST
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */

void WST_RXF_executeOnce( uint8 numberOfEvents )
{
#ifdef WST_MODELLING_RPY
	/* result only used for Rhapsody compatibility, where a destroy via vtable may be called */
	WST_EVT_handleEventStatus  result = WST_EVT_handleEventError;
#endif /* of WST_MODELLING_RPY */

	WST_EVT*    event;
	static WSTBoolean inUse = WSTFALSE;
	
	/* if the executeOnce function is called from different locations the flag inUse is used to protect this functions from race conditions */
	if( WSTFALSE == inUse )
	{
		inUse = WSTTRUE;
	
#if WST_TMM_MAX_IRQ_TIMEOUTS > 0
		WST_TMM_handleIRQTimeouts();
#endif /* WST_TMM_MAX_IRQ_TIMEOUTS > 0 */

		/* Process the timers before an event is processed,
		 * so expired timers will be processed imediately
		 */
		if ( WST_TMM_processedTicks != WSTRTOS_getRxfTicks() )
		{
			WST_TMM_processTimeouts();
		}
		
		/* if the event queue is not empty and less than the maximum of events per executeOnce call have been handled */
		if ( mainMSQ.eventHead != NULL && numberOfEvents > 0 )
		{
			numberOfEvents--;
			
			/* we have an event, so extract it from the event queue */
			event = WST_MSQ_get();
	
			if ( event != NULL )
			{
				if( (event->id != WST_TMR_delete_id) &&
					(event->id != WST_EVT_delete_id) )
				{
					if( event->destination == NULL )
					{
						WST_ERR_error( WST_ERR_NULL_DESTINATION );
					}
					else
					{
#ifdef WST_MODELLING_RPY
	/* result only used for Rhapsody compatibility, where a destroy via vtable may be called */
						result = 
#endif /* of WST_MODELLING_RPY */
					/* find out who needs to receive it and send it them */
						WST_FSM_takeEvent( event->destination, event );
					}
				}
	
				/* Now that the event has been processed, we must delete it. */
				if ( ( event->id == WST_TMR_id ) ||
					 ( event->id == WST_TMR_delete_id ))
				{
/*lint -save -e740 -e826 Unusual pointer cast (incompatible indirect types) */
/* @MISRA_11.4=OFF ID-0005: Rhapsody uses different types of event structures that need to be casted to each other, e.g. a timer event has to be casted to a normal event before it is consumed. */
	
					WST_TMM_putBack( (WST_TMR*) (event) );
	
/* @MISRA_11.4=ON */
/*lint -restore */
				}
				else
				{
					if ( event->isStatic == WSTFALSE )
					{
						WST_EVT_destroy( event );
					}
				}
#ifdef WST_MODELLING_RPY /* vtable only used for Rhapsody compatibility */
				/*
				 * Check if the statechart is finished. The Object must be destroyed then
				 */
				if (result == WST_EVT_handleEventReachTerminate)
				{
					if ( ( (event->destination != NULL)
						&& (event->destination->vtbl != NULL) )
						&& (event->destination->vtbl->destroyMethod != NULL) )
					{
						event->destination->vtbl->destroyMethod(event->destination->owner);
					}
					else
					{
						/* There is no need for FSM destruction here in the OO-RTX. */
					}
				}
	#endif /* WST_MODELLING_RPY */
			}
			else
			{

		
				if (WST_TMM_processedTicks != WSTRTOS_getRxfTicks())
				{
					WST_TMM_processTimeouts();
				}
				else
				{
					WSTTarget_sleep(1UL);
				}
			}
		}
		inUse = WSTFALSE;
	}
}

/* @MISRA_19.1=OFF PD-0001: The design requires memory type macro inclusions to be located in multiple locations within files */
#define WST_RXF_RUNNING_STOP_SEC_CODE_FAST
#include "WSTMemoryTypes.h"
/* @MISRA_19.1=ON */
